# Admit_01 Blockchain-Enabled eTicketing Platform

## Milestone 3b

### How to Compile
Since our code is written in Python, there is no need to compile.

### How to Run Our Code
Before doing anything else, you must execute 'make install' from the main directory in order to install the correct versions of pytest and pyqrcode.

To run frontend code, visit http://128.135.203.173:8000. You can click on the login link in the navbar to visit the login form. 

To login as a customer (someone who can buy tickets), use the following credentials: 
* username: joe 
* password: chicagomaroon

To login as a venue (someone who can list tickets), use the following credentials: 
* username: staff 
* password: chicagomaroon

You can logout by visiting the logout link in the navbar as well.

### How to Run the Unit Test Cases
You can use the Makefile to do so by executing 'make unit_tests' from the main directory. Please not that some of these tests may take upwards of two minutes to execute due to the rigor of the mining, and it occurring on the local machine.

### Suggestions for Acceptance Tests
To walk through our backend acceptance test, run this from terminal in the main directory:
make acceptance_test

This will walk you through all of the use cases, and finally save a .png file of the QR code of the ticket you will end up with. You will want to use reasonable ticket values (less than for example 1000000) in order to get through the entire simulation. Your user will not have enough money to complete the simulation in this case. The program will handle this appropriately, but you will not get to the end of the use cases.

You can test our application's authentication system by attempting to login on the preliminary site with correct and incorrect credentials (the credentials were enumerated in the **How to Run Our Code** section). 

Although the frontend and server end of buy and list ticket is implemented, acceptance testing is 
not stable as the frontend currently cannot display available tickets as that was not planned for iteration 1. Thus, the request server (where Django is run), cannot get a ticket from the blockchain server that it can purchase or list.

### What is Implemented?

#### Front end
The request, database, and blockchain servers have been created and can successfully communicate with one another. The blockchain server receives requests from the request server to modify the blockchain, and the request server in turn receives requests from a user's browser and returns responses generated by a web application (Django) that displays info retrieved from the blockchain and database servers.

Additionally, a primitive version of a web application has been implemented, and can be accessed via a browser. Users can, if already registered in the system (at this point, registration can only be done through Django's admin interface, which is accessible at 128.135.203.173:8000/admin), login to the site. The authentication system is fully capable and implemented. The site recognizes that a user is signed in through a sessions framework. 

#### Back end
On the back end, we have fully implemented the blockchain framework and currently have our transactions posting to two nodes (one held by the Event class, another held by the Venue class), though we are currently only using single-node validation. We will develop a three-point consensus mechanism in the second sprint, as planned.

In terms of use cases, we have fully and successfully implemented **Create Ticket**, **List Ticket**,  **Buy Ticket**, **Upgrade Ticket**, and **Generate Ticket Code**.

### Who Did What?

#### Front end
Pablo worked on creating virtual machines for the request, database, and blockchain servers. He also integrated the code written by the back end team so that the blockchain could communicate with the server instance on the blockchain server machine. 

Euirim worked on setting up the virtual machines with frameworks that would help us expediate development. He also setup the Django-based web application and coded the client-facing html that displayed a very primitive interface. Euirim also integrated the database server with the Django hosting request server.

#### Back end
Ross and Ethan paired to develop and test the *Trackers*, *User*, *Venue*, *Event*, *Seat*, and *Ticket* classes.

Hayden and Hussein paired to develop and test the *Block*, *Chain*, and *Transaction* classes.

We met together as a larger team on a few occassions to integrate our components and complete the implementations of the use cases.

### Changes from Implementation Plan
There were several several, code correctness, test rigor, formatting and changes to the unit tests, none of which changed the scope or diminished the coverage of the tests.

The only major change is that we incorporated the *Host* class into the *Venue* class, since we could no longer see a logical purpose for a standalone *Host* class. *Venue* objects now have access to the union of all use cases from the previous definition of *Host* and those from the previous definition of *Venue*.